<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Power Pong Deluxe</title>
   <link rel="icon" href="2025_09_13_0vp_Kleki.png" type="image/png">
  <style>
    /* Global reset and layout */
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #111 0%, #000 100%);
      color: white;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      min-height: 100vh;
      text-align: center;
    }

    /* Title styling */
    h1 {
      font-size: 3em;
      margin-top: 20px;
      color: #00ffcc;
      text-shadow: 0 0 20px #00ffcc, 0 0 40px #00ccff;
      letter-spacing: 2px;
      transition: transform 0.3s ease;
    }

    h1:hover {
      transform: scale(1.05);
    }

    /* Canvas styling */
    canvas {
      display: block;
      margin: 20px auto;
      background: #000;
      border: 2px solid #00ffcc;
      box-shadow: 0 0 30px #00ccff;
      width: 90%;
      height: auto;
      max-width: 800px;
      aspect-ratio: 16 / 10;
    }

    /* Footer / Copyright */
    footer {
      font-size: 0.9em;
      color: #888;
      padding: 10px 0;
      text-shadow: 0 0 10px #00ccff;
    }

    footer span {
      color: #00ffcc;
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
      h1 {
        font-size: 2em;
      }

      footer {
        font-size: 0.8em;
      }

      canvas {
        width: 95%;
        border-width: 1px;
      }
    }
  </style>
</head>

<body>
  <h1>Power Pong Deluxe</h1>
  <canvas id="pong" width="800" height="500"></canvas>

  <footer>Â© <span>Stenoip Company</span> 2025</footer>

<!-- 
Copyright Stenoip Company

Powerup Type	Color	Description/Effect
Speed	Red	    Increases ball speed.
Slow	Blue	 Decreases ball speed.
Invert	Green	Inverts the background color (toggles between black and white/light grey).
Disco	Yellow	 Makes the background flash random colors.
Ghost	White	Makes the ball translucent and the background a dark teal (#003333).
Gravity	Purple	Applies a continuous downward/upward acceleration (gravity) to the ball and changes the background to a dark purple (#220033).
-->
<script>
    var canvas = document.getElementById("pong");
    var ctx = canvas.getContext("2d");

    var paddleWidth = 10, paddleHeight = 100;
    var player = { x: 10, y: canvas.height / 2 - paddleHeight / 2, score: 0 };
    var ai = { x: canvas.width - paddleWidth - 10, y: canvas.height / 2 - paddleHeight / 2, score: 0 };
    var ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 10,
        speed: 5,
        dx: 5,
        dy: 0,
        color: "cyan",
        ghost: false,
        gravity: false
    };

    var powerups = [];
    var backgroundColor = "#000";
    var lastPowerupTime = 0;
    var activePowerup = null;
    var powerupEndTime = 0;

    // --- Sound Effect Definitions ---
    // NOTE: Replace the placeholder paths with your actual sound file paths!
    var hitSound = new Audio('./hit.wav');       // Ball-Paddle/Wall collision
    var scoreSound = new Audio('./score.wav');   // Player or AI scores
    var powerupSound = new Audio('./powerup.wav'); // Generic powerup pickup
    var gravitySound = new Audio('./gravity.wav'); // Special sound for Gravity powerup

    // Helper function to play a sound effect instantly and allow overlap
    function playSound(sound) {
        // Clone the audio node to allow for multiple, overlapping plays
        var clone = sound.cloneNode(true);
        clone.volume = 0.5; // Set volume to 50%
        // Use .catch() to suppress the error if the browser blocks autoplay
        clone.play().catch(e => { /* Audio playback was blocked, no-op */ }); 
    }
    // --- End Sound Effect Definitions ---


    // --- Browser Storage Functions ---
    function saveScore() {
        try {
            localStorage.setItem('playerScore', player.score);
            localStorage.setItem('aiScore', ai.score);
        } catch (e) {
            console.error("Could not save score to localStorage:", e);
        }
    }

    function loadScore() {
        try {
            var pScore = localStorage.getItem('playerScore');
            var aScore = localStorage.getItem('aiScore');

            if (pScore !== null && aScore !== null) {
                // If scores exist, ask the user if they want to continue
                if (confirm("Saved game found: Player " + pScore + " - AI " + aScore + ". Do you want to continue?")) {
                    player.score = parseInt(pScore);
                    ai.score = parseInt(aScore);
                    return; // Continue with loaded scores
                }
            }
        } catch (e) {
            console.error("Could not load score from localStorage:", e);
        }

        // If no saved game or user chose new game, reset scores
        player.score = 0;
        ai.score = 0;
        clearStorage();
    }

    function clearStorage() {
        try {
            localStorage.removeItem('playerScore');
            localStorage.removeItem('aiScore');
        } catch (e) {
            console.error("Could not clear localStorage:", e);
        }
    }
    // --- End Browser Storage Functions ---

    function drawRect(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
    }

    function drawPlasmaBall(x, y, r, color, ghost) {
        var gradient = ctx.createRadialGradient(x, y, r * 0.3, x, y, r);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, ghost ? "rgba(0,0,0,0.1)" : "transparent");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawNet() {
        for (var i = 0; i < canvas.height; i += 20) {
            drawRect(canvas.width / 2 - 1, i, 2, 10, "white");
        }
    }

    function drawText(text, x, y) {
        // Adjust text color based on inverted background
        ctx.fillStyle = backgroundColor === "#eee" ? "black" : "white"; 
        ctx.font = "40px Arial";
        ctx.fillText(text, x, y);
    }

    function resetBall() {
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        // The ball speed resets to 5 when a powerup ends (in clearPowerup) or when a new game starts.
        // We'll reset ball.dx magnitude to the current ball.speed value, which might be boosted by a powerup.
        ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
        ball.dy = 0;
    }

    function collision(paddle) {
        return ball.x - ball.radius < paddle.x + paddleWidth &&
            ball.x + ball.radius > paddle.x &&
            ball.y - ball.radius < paddle.y + paddleHeight &&
            ball.y + ball.radius > paddle.y;
    }

    function spawnPowerup() {
        var types = ["speed", "slow", "invert", "disco", "ghost", "gravity"];
        var type = types[Math.floor(Math.random() * types.length)];
        var px = Math.random() * (canvas.width - 100) + 50;
        var py = Math.random() * (canvas.height - 100) + 50;
        powerups.push({ x: px, y: py, r: 15, type: type });
        lastPowerupTime = Date.now();
    }

    function applyPowerup(type) {
        // Clear any previous powerup state first
        clearPowerup(); 
        
        activePowerup = type;
        powerupEndTime = Date.now() + 7000;
        
        // Play the generic powerup sound
        playSound(powerupSound); 

        if (type === "speed") {
            ball.speed += 3;
            backgroundColor = "#330000";
        } else if (type === "slow") {
            ball.speed = Math.max(3, ball.speed - 2);
            backgroundColor = "#001133";
        } else if (type === "invert") {
            backgroundColor = backgroundColor === "#000" ? "#eee" : "#000";
        } else if (type === "disco") {
            backgroundColor = "disco";
        } else if (type === "ghost") {
            ball.ghost = true;
            backgroundColor = "#003333";
        } else if (type === "gravity") {
            ball.gravity = true;
            backgroundColor = "#220033";
            // Play a distinct gravity sound
            playSound(gravitySound); 
        }

        // Re-calculate dx/dy based on the new speed
        ball.dx = (ball.dx > 0 ? 1 : -1) * ball.speed;
        // Re-calculate dy magnitude, keeping the original direction
        ball.dy = (ball.dy > 0 ? 1 : -1) * Math.abs(ball.dy / (ball.dy ? Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy) : 1)) * ball.speed;
    }

    function clearPowerup() {
        // Check if there was an active powerup before resetting
        if (activePowerup) {
            // If the background was inverted, un-invert it
            if (activePowerup === "invert" && backgroundColor === "#eee") {
                 backgroundColor = "#000";
            }
        }

        activePowerup = null;
        ball.speed = 5; // Reset to base speed
        ball.ghost = false;
        ball.gravity = false;
        
        // Reset background color to black unless it was inverted
        if (backgroundColor !== "#eee") {
            backgroundColor = "#000";
        }

        // Re-calculate dx/dy based on the base speed
        ball.dx = (ball.dx > 0 ? 1 : -1) * ball.speed;
        ball.dy = (ball.dy > 0 ? 1 : -1) * Math.abs(ball.dy / (ball.dy ? Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy) : 1)) * ball.speed;
    }

    function update() {
        if (ball.gravity) {
            // Apply continuous acceleration (gravity)
            // The direction of gravity is based on the initial vertical movement
            ball.dy += (ball.dy > 0 ? 0.05 : -0.05); 
        }

        ball.x += ball.dx;
        ball.y += ball.dy;

        // Ball hits top or bottom wall
        if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
            ball.dy = -ball.dy;
            playSound(hitSound); // Play wall bounce sound
        }

        var aiCenter = ai.y + paddleHeight / 2;
        var ballOffset = ball.y - aiCenter;
        var move = ballOffset * 0.05;
        var maxAiSpeed = 4;
        ai.y += Math.max(-maxAiSpeed, Math.min(maxAiSpeed, move));

        // Player collision
        if (collision(player)) {
            var angle = ((ball.y - (player.y + paddleHeight / 2)) / (paddleHeight / 2)) * Math.PI / 4;
            ball.dx = ball.speed * Math.cos(angle);
            ball.dy = ball.speed * Math.sin(angle);
            playSound(hitSound); // Play paddle hit sound
        }

        // AI collision
        if (collision(ai)) {
            var angle = ((ball.y - (ai.y + paddleHeight / 2)) / (paddleHeight / 2)) * Math.PI / 4;
            ball.dx = -ball.speed * Math.cos(angle);
            ball.dy = ball.speed * Math.sin(angle);
            playSound(hitSound); // Play paddle hit sound
        }

        // Scoring
        if (ball.x - ball.radius < 0) {
            ai.score++;
            playSound(scoreSound); // Play score sound
            saveScore(); // Save score after scoring
            resetBall();
        } else if (ball.x + ball.radius > canvas.width) {
            player.score++;
            playSound(scoreSound); // Play score sound
            saveScore(); // Save score after scoring
            resetBall();
        }

        // Powerup collision
        for (var i = powerups.length - 1; i >= 0; i--) {
            var p = powerups[i];
            var dx = ball.x - p.x;
            var dy = ball.y - p.y;
            if (Math.sqrt(dx * dx + dy * dy) < ball.radius + p.r) {
                applyPowerup(p.type);
                powerups.splice(i, 1);
            }
        }

        // Powerup spawn logic
        if (Date.now() - lastPowerupTime > 10000 && !activePowerup) {
            spawnPowerup();
        }

        // Powerup duration logic
        if (activePowerup && Date.now() > powerupEndTime) {
            clearPowerup();
        }
    }

    function render() {
        if (backgroundColor === "disco") {
            var r = Math.floor(Math.random() * 100 + 50);
            var g = Math.floor(Math.random() * 100 + 50);
            var b = Math.floor(Math.random() * 100 + 50);
            drawRect(0, 0, canvas.width, canvas.height, "rgb(" + r + "," + g + "," + b + ")");
        } else {
            drawRect(0, 0, canvas.width, canvas.height, backgroundColor);
        }

        drawNet();
        drawText(player.score, canvas.width / 4, 50);
        drawText(ai.score, 3 * canvas.width / 4, 50);
        
        var paddleColor = backgroundColor === "#eee" ? "black" : "white";
        drawRect(player.x, player.y, paddleWidth, paddleHeight, paddleColor);
        drawRect(ai.x, ai.y, paddleWidth, paddleHeight, paddleColor);
        drawPlasmaBall(ball.x, ball.y, ball.radius * 2, ball.color, ball.ghost);

        for (var i = 0; i < powerups.length; i++) {
            var p = powerups[i];
            ctx.fillStyle = p.type === "speed" ? "red" :
                p.type === "slow" ? "blue" :
                p.type === "invert" ? "green" :
                p.type === "disco" ? "yellow" :
                p.type === "ghost" ? "white" : "purple";
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    canvas.addEventListener("mousemove", function(evt) {
        var rect = canvas.getBoundingClientRect();
        player.y = evt.clientY - rect.top - paddleHeight / 2;
    });

    // --- Initialization ---
    // Load the score immediately when the script runs
    loadScore(); 
    
    // Start the game loop
    setInterval(function() {
        update();
        render();
    }, 1000 / 60);
    // --- End Initialization ---
</script>
</body>
</html>
